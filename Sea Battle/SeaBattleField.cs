using System;
using System.IO;
using System.Threading;

namespace Sea_Battle
{
    struct Point
    {
        public int X;
        public int Y;
        public Point(int x, int y)
        {
            this.X = x;
            this.Y = y;
        }
    }
    class SeaBattleField
    {
        //поля класса
        private byte[,] field; //поле, отвечающее за хранение состояний всех ячеек
        //возможные значения:
        //0 - ничего, 1 - целый корабль, 2 - подбитый корабль,
        //3 - уничтоженный корабль, 4 - не может быть части корабля, 5 - проверенное ничего
        private readonly int fSize = 10; //размер игрового поля
        private Random rnd; //генератор псевдослучайных чисел
        public int destroyedShipsCount = 0; //Переменная-счетчик уничтоженных кораблей


        //конструкторы класса
        //конструктор по умолчанию
        public SeaBattleField()
        {
            rnd = new Random();
            //Необходимо вызвать "паузу" в выполнении кода, поскольку
            //в большинстве систем Windows объекты, созданные в течение 15 миллисекундах друг от друга,
            //Random скорее всего, будут иметь одинаковые начальные значения
            Thread.Sleep(20);
            field = new byte[fSize, fSize];
            //цикл заполнения поля нулями
            for (int i = 0; i < fSize; i++)
            {
                for (int j = 0; j < fSize; j++)
                {
                    field[i, j] = 0;
                }
            }
            //вызов метода для случайной расстановки кораблей
            FillFieldRandomly();
        }
        //конструктор, предназначенный для того, чтобы создать копию входного поля
        public SeaBattleField(byte[,] insert, int d)
        {
            field = new byte[fSize, fSize];
            for (int i = 0; i < fSize; i++)
            {
                for (int j = 0; j < fSize; j++)
                {
                    field[i, j] = insert[i, j];
                }
            }
            destroyedShipsCount = d;
        }
        public SeaBattleField(SeaBattleField input)
        {
            //копирует объект класса Random
            rnd = input.rnd;
            field = new byte[fSize, fSize];
            //цикл, в котором все ячейки с кораблями из входного поля переносятся в текущее
            //Если корабль во входном был ранен или уничтожен, в текущем поле он будет целым
            //Остальные ячейки заполняются нулями
            for (int i = 0; i < fSize; i++)
            {
                for (int j = 0; j < fSize; j++)
                {
                    if (input.field[i, j] == 1 || input.field[i, j] == 2 || input.field[i, j] == 3)
                    {
                        field[i, j] = 1;
                        continue;
                    }
                    field[i, j] = 0;
                }
            }
            //Цикл, предназначенный для того, чтобы пометить все корабли границей,
            //в которой не может быть другого корабля, то есть, заполнить границы четверками
            for (int i = 0; i < fSize; i++)
            {
                for (int j = 0; j < fSize; j++)
                {
                    //Проверка на наличие части корабля
                    if (field[i, j] == 1)
                    {
                        //запуск цикла, проходящего вокруг всей части корабля
                        for (int m = i - 1; m <= i + 1; m++)
                        {
                            for (int n = j - 1; n <= j + 1; n++)
                            {
                                //следующая иттерация цикла в том случае, если индексы, по которым
                                //пытается обратится цикл, выходят за границы массива
                                if (m < 0 || m >= fSize || n < 0 || n >= fSize) continue;
                                //Следующая иттерация цикла в том случае, если ячейка занята частью корабля
                                if (field[m, n] == 1) continue;
                                field[m, n] = 4;
                            }
                        }
                    }
                }
            }
        }

        //рандомная генерация поля
        private void FillFieldRandomly()
        {
            //генерирует один четырехпалубный корабль 
            ShipGeneration(4);
            //генерирует два трехпалубника
            for (int i = 0; i < 2; i++) ShipGeneration(3);
            //три двухпалубника
            for (int i = 0; i < 3; i++) ShipGeneration(2);
            //четыре однопалубника
            for (int i = 0; i < 4; i++) ShipGeneration(1);

            //генерация корабля - на вход подается размер корабля
            void ShipGeneration(int size)
            {
                //переменная, которая сигнализирует о том, что корабль можно разместить
                bool readyToPlace = false;
                //цикл продолжается до тех пор, пока корабль нельзя разместить
                while (!readyToPlace)
                {
                    readyToPlace = true;
                    //корабль будет горизонтальным, либо вертикальным, в зависимости от рандома
                    bool horizontal = rnd.Next(0, 2) % 2 == 0;
                    //максимальная координата по горизонтали, в которую можно расположить первую часть корабля
                    //Горизонтальный? тогда от 0 до размера поля минус размер корабля ИНАЧЕ любая координата
                    int x = horizontal ? rnd.Next(0, fSize - size + 1) : rnd.Next(0, fSize);
                    //определение длины корабля по горизонтали
                    int xSize = horizontal ? size : 1;
                    //аналогичные переменные для координаты по вертикали
                    int y = horizontal ? rnd.Next(0, fSize) : rnd.Next(0, fSize - size + 1);
                    int ySize = horizontal ? 1 : size;

                    //цикл, в котором проверяется, можно ли в данных координатах расположить корабль
                    //соответствующей длины
                    for (int i = x; i < x + xSize; i++)
                    {
                        for (int j = y; j < y + ySize; j++)
                        {
                            //если корабль пересекает другой корабль или его границы, то...
                            if (field[i, j] == 1 || field[i, j] == 4)
                            {
                                //переменная, отвечающая за готовность расположения корабля принимает
                                //отрицательное значение
                                readyToPlace = false;
                            }
                        }
                    }

                    //продолжение цикла в том случае, если корабль нельзя разместить
                    //Координаты будут переопределены новым случайным образом 
                    if (!readyToPlace)
                    {
                        continue;
                    }

                    //далее идет часть кода, которая размещает корабль

                    //цикл размещения частей корабля
                    for (int i = x; i < x + xSize; i++)
                    {
                        for (int j = y; j < y + ySize; j++)
                        {
                            field[i, j] = 1;
                        }
                    }

                    //цикл размещения границ корабля
                    for (int i = x - 1; i < x + xSize + 1; i++)
                    {
                        for (int j = y - 1; j < y + ySize + 1; j++)
                        {
                            //если вышли за границы массива, то следующий заход в цикл
                            if (i < 0 || j < 0 || i > fSize - 1 || j > fSize - 1)
                            {
                                continue;
                            }

                            //расположение границы корабля
                            if (field[i, j] != 1)
                            {
                                field[i, j] = 4;
                            }
                        }
                    }
                }
            }

        }

        //возврат значения в ячейке поля //6 в случае выхода за границы поля
        public byte GetFieldCellValue(int x, int y)
        {
            if (x < 0 || x >= fSize || y < 0 || y >= fSize) return 6;
            return field[x, y];
        }

        //выстрел по полю
        public byte ShootIntoFieldCell(int x, int y)
        {
            switch (field[x, y])
            {
                //выстрел мимо! новое значение в ячейке - проверенное ничего
                case 0:
                    field[x, y] = 5;
                    return 5;
                //попал! 
                case 1:
                    //новое значение ячейки поля
                    field[x, y] = 2;

                    //для упрощения и ускорения игрового процесса, угловые ячейки стреленной
                    //ячейки помечаются пятеркой (проверенное ничего), поскольку в этих 
                    //ячейках не может быть части корабля, независимо от его направления
                    if (x - 1 >= 0 && y - 1 >= 0) field[x - 1, y - 1] = 5;
                    if (x - 1 >= 0 && y + 1 < fSize) field[x - 1, y + 1] = 5;
                    if (x + 1 < fSize && y - 1 >= 0) field[x + 1, y - 1] = 5;
                    if (x + 1 < fSize && y + 1 < fSize) field[x + 1, y + 1] = 5;

                    //необходимо проверить, вдруг корабль был уничтожен, а не ранен
                    //массив точек частей корабля
                    Point[] points = new Point[4];
                    //длина корабля
                    int length = 0;
                    //запомнили первую точку, в которую был произведен текущий выстрел
                    points[length++] = new Point(x, y);

                    //проверяем по вертикали вниз
                    for (int i = 1; i < 5; i++)
                    {
                        //вышли за границы массива - завершаем цикл
                        if (x - i < 0) break;
                        //попали в границу или в проверенную ячейку - завершаем цикл
                        if (field[x - i, y] == 4 || field[x - i, y] == 5) break;
                        //корабль был лишь ранен - завершаем работу метода и возвращаем 
                        //информацию о том, что корабль ранен
                        if (field[x - i, y] == 1) return 2;
                        //ни одно из условий не выполнено, значит текущая точка - 
                        // раненная часть корабля - запоминаем эту точку
                        points[length++] = new Point(x - i, y);
                    }
                    //аналогично для движения по вертикали вверх
                    for (int i = 1; i < 5; i++)
                    {
                        if (x + i > 9) break;
                        if (field[x + i, y] == 4 || field[x + i, y] == 5) break;
                        if (field[x + i, y] == 1) return 2;
                        points[length++] = new Point(x + i, y);
                    }
                    //аналогично для движения по горизонтали влево
                    for (int i = 1; i < 5; i++)
                    {
                        if (y - i < 0) break;
                        if (field[x, y - i] == 4 || field[x, y - i] == 5) break;
                        if (field[x, y - i] == 1) return 2;
                        points[length++] = new Point(x, y - i);
                    }
                    //аналогично для движения по горизонтали вправо
                    for (int i = 1; i < 5; i++)
                    {
                        if (y + i > 9) break;
                        if (field[x, y + i] == 4 || field[x, y + i] == 5) break;
                        if (field[x, y + i] == 1) return 2;
                        points[length++] = new Point(x, y + i);
                    }

                    //проверили все возможные направления расположения корабля
                    //корабль был уничтожен окончательно

                    //Добавляем в переменную-счетчик уничтоженный корабль
                    destroyedShipsCount += 1;
                    //запускаем цикл для изменения состояния всего корабля
                    for (int i = 0; i < length; i++)
                    {
                        //запоминаем, что раненные части теперь уничтоженные
                        field[points[i].X, points[i].Y] = 3;
                        //также для упрощения и ускорения игрового процесса
                        //сразу выставляем границы корабля, в которых не может
                        //быть другого корабля или его части
                        for (int j = points[i].X - 1; j < points[i].X + 2; j++)
                        {
                            for (int h = points[i].Y - 1; h < points[i].Y + 2; h++)
                            {
                                if (j < 0 || j > 9 || h < 0 || h > 9) continue;
                                if (field[j, h] == 2) field[j, h] = 3;
                                if (field[j, h] == 4) field[j, h] = 5;
                            }
                        }
                    }
                    //возвращаем состояние корабля
                    return 3;
                //попали в границу корабля, теперь здесь проверенное ничего
                case 4:
                    field[x, y] = 5;
                    return 5;
            }
            //остальные случаи попаданий игнорируются, поскольку не несут
            //за собой каких-либо действий
            //Однако не все пути ведут к возврату значения, поэтому добавляем
            //возврат нуля по умолчанию, который говорит о том, что выстрел
            //не был засчитан
            return 0;
        }
    }
}